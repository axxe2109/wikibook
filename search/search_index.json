{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Certificaciones Linux","title":"Inicio"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#certificaciones","text":"","title":"Certificaciones"},{"location":"#linux","text":"","title":"Linux"},{"location":"ckad/","text":"CKAD Configuration 001 - Define, build and modify container images How to create my own image? Ejemplo: Crear una imagen para una aplicacion web sencilla 1. Anotar los pasos del proceso de como se haria manualmente. 2. Crear el archivo Dockerfile con las instrucciones 3. Crear la imagen con el comando de compilacion de Docker 4. Subir la imagen a dockerfile para que sea publica Dockerfile Layered architecture Docker build output failure 002 - Commands docker build -t webapp-color . 003 - Commands and Arguments in Docker docker run ubuntu : Crea y ejecuta un contenedor con la imagen ubuntu . docker ps : Muestra los contenedores activos en ejecuci\u00f3n. docker ps -a : Lista todos los contenedores, incluidos los detenidos. docker run ubuntu [COMMAND] : Ejecuta un contenedor basado en ubuntu con el comando especificado. docker run ubuntu sleep 5 : Inicia un contenedor con ubuntu y ejecuta el comando sleep 5 (espera 5 segundos). docker build -t ubuntu-sleeper . : Construye una imagen llamada ubuntu-sleeper a partir del Dockerfile en el directorio actual. docker run ubuntu-sleeper : Ejecuta un contenedor basado en la imagen ubuntu-sleeper . docker run ubuntu-sleeper sleep 10 docker run ubuntu-sleeper 10 004 - Commands and Arguments in Kubernetes docker run --name ubuntu-sleeper ubuntu-sleeper docker run --name ubuntu-sleeper ubuntu sleeper 10 005 - A quick note on editing Pods and Deployments A quick note on editing Pods and Deployments Edit a POD Remember, you CANNOT edit specifications of an existing POD other than the below. - spec.containers\\[\\*\\].image - spec.initContainers\\[\\*\\].image - spec.activeDeadlineSeconds - spec.tolerations For example you cannot edit the environment variables, service accounts, resource limits (all of which we will discuss later) of a running pod. But if you really want to, you have 2 options: 1. Run the kubectl edit pod <pod name> command. This will open the pod specification in an editor (vi editor). Then edit the required properties. When you try to save it, you will be denied. This is because you are attempting to edit a field on the pod that is not editable. ![](https://img-c.udemycdn.com/redactor/raw/2019-05-30_14-46-21-89ea56fea6b993ee0ccff1625b13341e.PNG) ![](https://img-c.udemycdn.com/redactor/raw/2019-05-30_14-47-14-07b2638d1a72cb2d5b000c00971f6436.PNG) A copy of the file with your changes is saved in a temporary location as shown above. You can then delete the existing pod by running the command: kubectl delete pod webapp Then create a new pod with your changes using the temporary file kubectl create -f /tmp/kubectl-edit-ccvrq.yaml 2. The second option is to extract the pod definition in YAML format to a file using the command kubectl get pod webapp -o yaml > my-new-pod.yaml Then make the changes to the exported file using an editor (vi editor). Save the changes vi my-new-pod.yaml Then delete the existing pod kubectl delete pod webapp Then create a new pod with the edited file kubectl create -f my-new-pod.yaml Edit Deployments With Deployments you can easily edit any field/property of the POD template. Since the pod template is a child of the deployment specification, with every change the deployment will automatically delete and create a new pod with the new changes. So if you are asked to edit a property of a POD part of a deployment you may do that simply by running the command kubectl edit deployment my-deployment 006 - Environment Variables En Kubernetes, las Environment Variables son configuraciones que puedes pasar a los contenedores para personalizar su comportamiento. Se definen en el manifiesto del pod o Deployment bajo la secci\u00f3n env . Estas variables pueden tener valores fijos o din\u00e1micos, obtenidos de ConfigMaps o Secrets, y son \u00fatiles para almacenar configuraciones como credenciales o URLs sin codificarlas directamente. Ejemplo de configuraci\u00f3n: ```yaml env: - name: APP_ENV value: production - name: DATABASE_URL valueFrom: secretKeyRef: name: db-secret key: url [![image.png](http://10.10.56.89/uploads/images/gallery/2025-01/scaled-1680-/zwUimage.png)](http://10.10.56.89/uploads/images/gallery/2025-01/zwUimage.png) En Kubernetes, los valores de las **Environment Variables** pueden definirse de tres formas principales: - **Valores fijos**: Se especifican directamente en el manifiesto. ```yaml env: - name: APP_ENV value: production Valores din\u00e1micos desde ConfigMaps o Secrets : Se obtienen de estos objetos para gestionar configuraciones sensibles o centralizadas env: - name: DATABASE_URL valueFrom: configMapKeyRef: name: app-config key: database_url 007 - ConfigMaps Un ConfigMap en Kubernetes es un objeto utilizado para almacenar datos de configuraci\u00f3n no sensibles en pares clave-valor. Permite desacoplar la configuraci\u00f3n del c\u00f3digo de la aplicaci\u00f3n, haciendo que sea m\u00e1s f\u00e1cil modificar configuraciones sin necesidad de redeployar. Los ConfigMaps pueden ser referenciados en pods como variables de entorno, archivos montados en vol\u00famenes o argumentos del contenedor. Esto los hace ideales para gestionar configuraciones como URLs, nombres de servidores y par\u00e1metros de aplicaciones. Imperative Declarative Core Concepts 001 - Recap - Kubernetes Architecture Node: Un Node en Kubernetes es una m\u00e1quina (f\u00edsica o virtual) que ejecuta los pods, proporcionando los recursos de CPU, memoria, red y almacenamiento necesarios. Cada Node tiene un agente kubelet que comunica su estado con el cl\u00faster y administra los contenedores Cluster: Un Cluster en Kubernetes es un conjunto de nodos (m\u00e1quinas) que trabajan juntos para ejecutar aplicaciones en contenedores. Est\u00e1 compuesto por un control plane que gestiona el estado del cl\u00faster y los nodes que ejecutan los workloads Master: El Master en Kubernetes (o Control Plane) es el componente central que administra el cl\u00faster, coordinando las actividades de los nodos. Incluye el API Server , Scheduler , Controller Manager y etcd para gestionar el estado y la configuraci\u00f3n del cl\u00faster. Componentes: Los componentes principales de Kubernetes son: Control Plane : API Server : Gestiona la comunicaci\u00f3n entre los usuarios y el cl\u00faster. etcd : Almac\u00e9n clave-valor para el estado del cl\u00faster. Scheduler : Asigna pods a nodos seg\u00fan recursos y pol\u00edticas. Controller Manager : Gestiona controladores, como replicaci\u00f3n y endpoints. Node Components : Kubelet : Agente que asegura que los contenedores est\u00e9n en ejecuci\u00f3n. Kube-proxy : Gestiona la red y el acceso a los servicios. Container Runtime : Ejecuta contenedores (e.g., Docker, containerd). Master vs Worker Nodes Master Node (Control Plane): Administra el cl\u00faster y toma decisiones como programar pods. Componentes clave: API Server , etcd , Scheduler , y Controller Manager . No ejecuta aplicaciones directamente (excepto en cl\u00fasteres peque\u00f1os, como Minikube). Worker Node: Ejecuta los pods con las aplicaciones y cargas de trabajo. Componentes clave: Kubelet , Kube-proxy , y el Container Runtime . Recibe instrucciones del Master Node para ejecutar y gestionar los pods. En resumen, el Master coordina y los Worker Nodes ejecutan. Kubectl kubectl es la herramienta de l\u00ednea de comandos para interactuar con un cl\u00faster de Kubernetes. Permite gestionar recursos como pods, servicios, y deployments, as\u00ed como monitorear el estado del cl\u00faster y ejecutar comandos en los contenedores. 002 - Docker-vs-ContainerD Docker : Descripci\u00f3n : Docker es una plataforma completa que facilita la creaci\u00f3n, env\u00edo y ejecuci\u00f3n de contenedores. Incluye un conjunto de herramientas como el Docker Engine , Docker Compose , y Docker Hub . Uso : Adem\u00e1s de ejecutar contenedores, tambi\u00e9n gestiona la construcci\u00f3n de im\u00e1genes y la orquestaci\u00f3n con Docker Swarm. containerd : Descripci\u00f3n : containerd es un runtime de contenedores que proporciona las funcionalidades b\u00e1sicas necesarias para ejecutar contenedores, como la ejecuci\u00f3n de contenedores, la gesti\u00f3n de im\u00e1genes y la administraci\u00f3n del ciclo de vida de los contenedores. Es m\u00e1s ligero y especializado en la ejecuci\u00f3n de contenedores, sin las herramientas adicionales que ofrece Docker. Uso : Usado por Kubernetes y otras plataformas de contenedores para gestionar la ejecuci\u00f3n de contenedores. Diferencia clave: Docker es m\u00e1s una plataforma completa que gestiona todo el ciclo de vida de los contenedores, mientras que containerd se centra en la ejecuci\u00f3n y gesti\u00f3n de contenedores, siendo m\u00e1s eficiente para proyectos espec\u00edficos. 003 - Recap - Pods POD Un Pod en Kubernetes es la unidad b\u00e1sica de despliegue que puede contener uno o m\u00e1s contenedores (t\u00edpicamente en el mismo host). Los contenedores dentro de un pod comparten el mismo almacenamiento, red y especificaciones, lo que permite una estrecha comunicaci\u00f3n y gesti\u00f3n eficiente. Los pods son ef\u00edmeros y gestionados por el control plane de Kubernetes. Multi-Container Pod Un Multi-Container Pod en Kubernetes es un pod que contiene m\u00e1s de un contenedor. Estos contenedores comparten red, almacenamiento y contexto, permitiendo una comunicaci\u00f3n eficiente. Se usan para patrones como: Sidecar : Un contenedor complementa al principal, como un proxy o logger. Adapter : Transforma datos para otro contenedor en el mismo pod. Ambassador : Maneja la comunicaci\u00f3n con servicios externos. Todos los contenedores trabajan como una unidad cohesiva para cumplir un objetivo com\u00fan. Kubectl 004 - Pods with YAML YAML YAML (Yet Another Markup Language) es un formato de texto legible para humanos usado en Kubernetes para definir recursos del cl\u00faster. Es jer\u00e1rquico y utiliza espacios para estructurar datos en clave-valor. Cuatro campos de nivel superior Comandos kubectl run redis --image=redis123 --dry-run=client -o yaml 005 - Creating Pod with YAML apiVersion: v1 kind: Pod metadata: name: myapp-pod labels: app: myapp costcenter: amer location: MX spec: containers: - name: nginx-container image: nginx 006 - Edit PODS Edit Pods A Note on Editing Existing Pods In any of the practical quizzes, if you are asked to edit an existing POD , please note the following: - If you are given a pod definition file, edit that file and use it to create a new pod. - **If you are not given a pod definition file**, you may extract the definition to a file using the below command: `kubectl get pod -o yaml > pod-definition.yaml` Then edit the file to make the necessary changes, delete, and re-create the pod. - To modify the properties of the pod, you can utilize the `kubectl edit pod `command. Please note that only the properties listed below are editable. - spec.containers\\[\\*\\].image - spec.initContainers\\[\\*\\].image - spec.activeDeadlineSeconds - spec.tolerations - spec.terminationGracePeriodSeconds 007 - Replicasets Replica Una r\u00e9plica en Kubernetes es una instancia de un pod que forma parte de un ReplicaSet o Deployment. Su prop\u00f3sito es garantizar alta disponibilidad y escalabilidad al duplicar aplicaciones en varios nodos. El n\u00famero de r\u00e9plicas se define en el campo replicas en el manifiesto YAML del recurso. Por ejemplo, con replicas: 3 , Kubernetes mantiene siempre tres pods activos. ccReplicaset Un ReplicaSet en Kubernetes asegura que un n\u00famero espec\u00edfico de r\u00e9plicas de un pod est\u00e9n siempre corriendo en el cl\u00faster. Si un pod falla o es eliminado, el ReplicaSet lo reemplaza autom\u00e1ticamente. Replicaset Controller El ReplicaSet Controller es un controlador en Kubernetes que gestiona los recursos ReplicaSet . Su funci\u00f3n principal es garantizar que el n\u00famero deseado de r\u00e9plicas de un pod est\u00e9 siempre en ejecuci\u00f3n en el cl\u00faster. Funciones clave del ReplicaSet Controller: Mantener el n\u00famero de r\u00e9plicas: Si un pod falla o se elimina, crea uno nuevo para cumplir con el n\u00famero especificado en replicas . Autoescalado: Permite aumentar o disminuir manualmente el n\u00famero de r\u00e9plicas seg\u00fan las necesidades. Reconciliaci\u00f3n: Compara constantemente el estado actual del cl\u00faster con el estado deseado y act\u00faa para mantenerlos alineados. Crear Replicacion Controller rc-definition.yml apiVersion: v1 kind: ReplicationController metadata: name: myapp-rc labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 2 ```bash kubectl create -f rc-definition.yml ```bash kubectl get replicationcontroller Crear ReplicaSet replicaset-definition.yml apiVersion: apps/v1 kind: ReplicaSet metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 3 selector: matchLabels: type: front-end ```bash kubectl create -f replicaset-definition.yml ```bash kubectl get replicaset Labels and Selectors Scale kubectl replace -f replicaset-definition.yml kubectl scale --replicas=7 -f replicaset-definition.yml kubectl scale --replicas=8 replicaset myapp-replicaset 008 - Deployments Deployment Un Deployment en Kubernetes es un recurso que administra la creaci\u00f3n y el escalado de pods, asegurando que siempre cumplan con el estado deseado. Facilita las actualizaciones y escalabilidad de aplicaciones. Permite implementar estrategias como actualizaciones progresivas (rolling updates) y revertir cambios si algo falla. Es ideal para gestionar aplicaciones de forma declarativa y mantener alta disponibilidad. Rolling updates Las rolling updates en Kubernetes son una estrategia para actualizar aplicaciones sin interrupciones. Kubernetes reemplaza gradualmente los pods antiguos por nuevos, asegurando que la aplicaci\u00f3n permanezca disponible durante el proceso. Se controla el n\u00famero de pods que se crean o eliminan simult\u00e1neamente usando los par\u00e1metros maxUnavailable y maxSurge en el Deployment. Esto permite realizar actualizaciones de forma segura y progresiva. Definition Un Deployment en Kubernetes est\u00e1 compuesto por los siguientes elementos clave: Metadata : Incluye informaci\u00f3n como el nombre del Deployment y etiquetas que ayudan a identificar recursos asociados. Spec (Especificaci\u00f3n) : Define el estado deseado, incluyendo el n\u00famero de r\u00e9plicas, el selector de pods, y la plantilla del pod (contenedores, im\u00e1genes y configuraciones). Selector : Identifica los pods gestionados por el Deployment bas\u00e1ndose en etiquetas. deployment-definition.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 6 selector: matchLabels: type: front-end ``` kubectl create -f deployment-definition.yaml kubectl get deployments kubectl get replicaset kubectl get pods kubectl get all # 009 - Certification Tip: Formatting Output with kubectl The default output format for all **kubectl** commands is the human-readable plain-text format. The -o flag allows us to output the details in several different formats. **kubectl \\[command\\] \\[TYPE\\] \\[NAME\\] -o &lt;output\\_format&gt;** Here are some of the commonly used formats: 1. `-o json`Output a JSON formatted API object. 2. `-o name`Print only the resource name and nothing else. 3. `-o wide`Output in the plain-text format with any additional information. 4. `-o yaml`Output a YAML formatted API object. Here are some useful examples: - **Output with JSON format:** ```json master $ kubectl create namespace test-123 --dry-run -o json { \"kind\": \"Namespace\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"test-123\", \"creationTimestamp\": null }, \"spec\": {}, \"status\": {} } master $ Output with YAML format: master $ kubectl create namespace test-123 --dry-run -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: null name: test-123 spec: {} status: {} Output with wide (additional details): Probably the most common format used to print additional details about the object: master $ kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES busybox 1/1 Running 0 3m39s 10.36.0.2 node01 <none> <none> ningx 1/1 Running 0 7m32s 10.44.0.1 node03 <none> <none> redis 1/1 Running 0 3m59s 10.36.0.1 node01 <none> <none> master $ For more details, refer: https://kubernetes.io/docs/reference/kubectl/overview/ https://kubernetes.io/docs/reference/kubectl/cheatsheet / 010 - Namespaces Un namespace en Kubernetes es un mecanismo l\u00f3gico para dividir recursos dentro de un cl\u00faster. Ayuda a organizar y aislar aplicaciones, facilitando la gesti\u00f3n de m\u00faltiples equipos o entornos (como desarrollo, pruebas y producci\u00f3n) en un mismo cl\u00faster. Los namespaces permiten que recursos con el mismo nombre coexistan en el cl\u00faster, siempre que pertenezcan a namespaces diferentes. Kubernetes incluye namespaces predeterminados como default , kube-system y kube-public . El aislamiento en namespaces de Kubernetes permite separar recursos y configuraciones entre diferentes espacios l\u00f3gicos dentro del cl\u00faster. Esto asegura que las aplicaciones o servicios de un namespace no interfieran con los de otro. Cada namespace tiene su propio conjunto de recursos, como pods, servicios y configuraciones, permitiendo un control granular de acceso mediante roles y pol\u00edticas ( Role y RoleBinding ). Este enfoque es \u00fatil para gestionar m\u00faltiples equipos o entornos en un mismo cl\u00faster. n Kubernetes, los namespaces pueden tener l\u00edmites de recursos definidos para controlar el consumo de CPU y memoria dentro de ellos. Esto se logra utilizando un objeto llamado ResourceQuota , que establece restricciones en el uso total de recursos en un namespace espec\u00edfico. Por ejemplo, se puede limitar la cantidad total de memoria o CPU que los pods en un namespace pueden usar, evitando que una aplicaci\u00f3n consuma m\u00e1s de lo asignado y afecte a otras aplicaciones en el cl\u00faster. Esto mejora la gesti\u00f3n de recursos y la estabilidad del sistema. Un ResourceQuota en Kubernetes es un objeto que impone l\u00edmites en el uso total de recursos dentro de un namespace. Controla la cantidad de recursos como CPU, memoria, pods, servicios y almacenamiento que los usuarios o aplicaciones pueden consumir en ese namespace. Se utiliza para evitar que un namespace consuma m\u00e1s recursos de los permitidos, asegurando una distribuci\u00f3n justa en el cl\u00faster. Es especialmente \u00fatil en cl\u00fasteres compartidos por m\u00faltiples equipos o aplicaciones. 011 - Certification Tip: Imperative Commands While you would be working mostly the declarative way - using definition files, imperative commands can help in getting one-time tasks done quickly, as well as generate a definition template easily. This would help save a considerable amount of time during your exams. Before we begin, familiarize yourself with the two options that can come in handy while working with the below commands: --dry-run : By default, as soon as the command is run, the resource will be created. If you simply want to test your command, use the --dry-run=client option. This will not create the resource. Instead, tell you whether the resource can be created and if your command is right. -o yaml : This will output the resource definition in YAML format on the screen. Use the above two in combination along with Linux output redirection to generate a resource definition file quickly, that you can then modify and create resources as required, instead of creating the files from scratch. kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx-pod.yaml POD Create an NGINX Pod kubectl run nginx --image=nginx Generate POD Manifest YAML file (-o yaml). Don't create it(--dry-run) kubectl run nginx --image=nginx --dry-run=client -o yaml Deployment Create a deployment kubectl create deployment --image=nginx nginx Generate Deployment YAML file (-o yaml). Don't create it(--dry-run) kubectl create deployment --image=nginx nginx --dry-run -o yaml Generate Deployment with 4 Replicas kubectl create deployment nginx --image=nginx --replicas=4 You can also scale deployment using the kubectl scale command. kubectl scale deployment nginx --replicas=4 Another way to do this is to save the YAML definition to a file and modify kubectl create deployment nginx --image=nginx --dry-run=client -o yaml > nginx-deployment.yaml You can then update the YAML file with the replicas or any other field before creating the deployment. Service Create a Service named redis-service of type ClusterIP to expose pod redis on port 6379 kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml (This will automatically use the pod's labels as selectors) Or kubectl create service clusterip redis --tcp=6379:6379 --dry-run=client -o yaml (This will not use the pods' labels as selectors; instead it will assume selectors as app=redis. You cannot pass in selectors as an option. So it does not work well if your pod has a different label set. So generate the file and modify the selectors before creating the service) Create a Service named nginx of type NodePort to expose pod nginx's port 80 on port 30080 on the nodes: kubectl expose pod nginx --port=80 --name nginx-service --type=NodePort --dry-run=client -o yaml (This will automatically use the pod's labels as selectors, but you cannot specify the node port . You have to generate a definition file and then add the node port in manually before creating the service with the pod.) Or kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml (This will not use the pods' labels as selectors) Both the above commands have their own challenges. While one of it cannot accept a selector the other cannot accept a node port. I would recommend going with the kubectl expose command. If you need to specify a node port, generate a definition file using the same command and manually input the nodeport before creating the service. Reference: https://kubernetes.io/docs/reference/kubectl/conventions/ Practice Test 001 - Pods Create a new pod with the nginx image. kubectl run nginx --image=nginx Delete the webapp Pod. kubectl delete pod webapp Create a new pod with the name redis and the image redis123 . Metodo 1: kubectl run redis --image=redis123 -o yaml pod-definition.yaml apiVersion: v1 kind: Pod metadata: creationTimestamp: \"2025-01-27T19:03:35Z\" labels: run: redis name: redis namespace: default resourceVersion: \"1059\" uid: 74c5fb2d-9479-4d03-ba3b-509663a2245b spec: containers: - image: redis123 imagePullPolicy: Always name: redis resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /var/run/secrets/kubernetes.io/serviceaccount name: kube-api-access-5k4xq readOnly: true dnsPolicy: ClusterFirst enableServiceLinks: true preemptionPolicy: PreemptLowerPriority priority: 0 restartPolicy: Always schedulerName: default-scheduler securityContext: {} serviceAccount: default serviceAccountName: default terminationGracePeriodSeconds: 30 tolerations: - effect: NoExecute key: node.kubernetes.io/not-ready operator: Exists tolerationSeconds: 300 - effect: NoExecute key: node.kubernetes.io/unreachable operator: Exists tolerationSeconds: 300 volumes: - name: kube-api-access-5k4xq projected: defaultMode: 420 sources: - serviceAccountToken: expirationSeconds: 3607 path: token - configMap: items: - key: ca.crt path: ca.crt name: kube-root-ca.crt - downwardAPI: items: - fieldRef: apiVersion: v1 fieldPath: metadata.namespace path: namespace status: phase: Pending qosClass: BestEffort Metodo 2: pod-definition-v1.yaml apiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis123 002 - Replicasets Create a ReplicaSet using the replicaset-definition-1.yaml file located at /root/ . There is an issue with the file, so try to fix it. Issue apiVersion: v1 kind: ReplicaSet metadata: name: replicaset-1 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: frontend spec: containers: - name: nginx image: nginx ```bash kubectl api-resources | grep replicaset <details id=\"bkmrk-fixed-apiversion%3A-ap\"><summary>Fixed</summary> ```yaml apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-1 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: frontend spec: containers: - name: nginx image: nginx Fix the issue in the replicaset-definition-2.yaml file and create a ReplicaSet using it. This file is located at /root/ . Issue apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-2 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: nginx spec: containers: - name: nginx image: nginx Fixed apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-2 spec: replicas: 2 selector: matchLabels: tier: nginx template: metadata: labels: tier: nginx spec: containers: - name: nginx image: nginx Fix the original replica set new-replica-set to use the correct busybox image. Either delete and recreate the ReplicaSet or Update the existing ReplicaSet and then delete all PODs, so new ones with the correct image will be created. kubectl edit replicaset new-replica-set Issue apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 2 name: new-replica-set namespace: default resourceVersion: \"1593\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 4 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox777 imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: fullyLabeledReplicas: 4 observedGeneration: 2 replicas: 4 Fixed apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 2 name: new-replica-set namespace: default resourceVersion: \"1593\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 4 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: fullyLabeledReplicas: 4 observedGeneration: 2 replicas: 4 ```bash kubectl delete pod new-replica-set-mr7mk new-replica-set-rvlcc new-replica-set-vn9fs Scale the ReplicaSet to 5 PODs. Use `kubectl scale` command or edit the replicaset using `kubectl edit replicaset`. Metodo Imperativo ```bash kubectl scale --replicas=5 rs/new-replica-set Metodo Declarativo kubectl edit rs new-replica-set apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 7 name: new-replica-set namespace: default resourceVersion: \"1955\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 5 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: availableReplicas: 5 fullyLabeledReplicas: 5 observedGeneration: 7 readyReplicas: 5 replicas: 5 Now scale the ReplicaSet down to 2 PODs. Use the kubectl scale command or edit the replicaset using kubectl edit replicaset . kubectl scale --replicas=2 rs/new-replica-set 003 - Deployments Create a new Deployment using the deployment-definition-1.yaml file located at /root/ . There is an issue with the file, so try to fix it. --- apiVersion: apps/v1 kind: deployment metadata: name: deployment-1 spec: replicas: 2 selector: matchLabels: name: busybox-pod template: metadata: labels: name: busybox-pod spec: containers: - name: busybox-container image: busybox888 command: - sh - \"-c\" - echo Hello Kubernetes! && sleep 3600 deployment-definition-1.yaml \\[Fixed\\] --- apiVersion: apps/v1 kind: Deployment metadata: name: deployment-1 spec: replicas: 2 selector: matchLabels: name: busybox-pod template: metadata: labels: name: busybox-pod spec: containers: - name: busybox-container image: busybox command: - sh - \"-c\" - echo Hello Kubernetes! && sleep 3600 Create a new Deployment with the below attributes using your own deployment definition file. Name: httpd-frontend ; Replicas: 3 ; Image: httpd:2.4-alpine 004 - Namespaces How many pods exist in the research namespace? Solution kubectl get pods -n research Create a POD in the finance namespace. Use the spec given below. - Name: redis - Image name: redis Solution kubectl run redis --image=redis -n finance Which namespace has the `blue` pod in it? Hint kubectl get pods --all-namespaces 005 - Imperative Commands Skels 001 - Pods apiVersion: v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: Pod # Obligatorio: Tipo de recurso (en este caso, Pod). metadata: name: <nombre-del-pod> # Obligatorio: Nombre \u00fanico del Pod. labels: # Opcional: Etiquetas para identificar el Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\" restartPolicy: Always # Opcional: Pol\u00edtica de reinicio (Always, OnFailure, Never). 002 - Replicasets apiVersion: apps/v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: ReplicaSet # Obligatorio: Tipo de recurso (en este caso, ReplicaSet). metadata: name: <nombre-del-replicaset> # Obligatorio: Nombre \u00fanico del ReplicaSet. labels: # Opcional: Etiquetas para identificar el ReplicaSet. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del ReplicaSet. replicas: <n\u00famero-de-r\u00e9plicas> # Obligatorio: N\u00famero de Pods que deseas ejecutar. selector: # Obligatorio: Selector para identificar los Pods gestionados. matchLabels: app: <etiqueta-app> # Debe coincidir con las etiquetas del Pod. template: # Obligatorio: Plantilla para crear los Pods. metadata: labels: # Obligatorio: Etiquetas del Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\" 003 - Deployments apiVersion: apps/v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: Deployment # Obligatorio: Tipo de recurso (en este caso, Deployment). metadata: name: <nombre-del-deployment> # Obligatorio: Nombre \u00fanico del Deployment. labels: # Opcional: Etiquetas para identificar el Deployment. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Deployment. replicas: <n\u00famero-de-r\u00e9plicas> # Opcional: N\u00famero de Pods que deseas ejecutar (por defecto es 1). selector: # Obligatorio: Selector para identificar los Pods gestionados. matchLabels: app: <etiqueta-app> # Debe coincidir con las etiquetas del Pod. template: # Obligatorio: Plantilla para crear los Pods. metadata: labels: # Obligatorio: Etiquetas del Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\"","title":"CKAD"},{"location":"ckad/#ckad","text":"","title":"CKAD"},{"location":"ckad/#configuration","text":"","title":"Configuration"},{"location":"ckad/#001-define-build-and-modify-container-images","text":"","title":"001 - Define, build and modify container images"},{"location":"ckad/#how-to-create-my-own-image","text":"Ejemplo: Crear una imagen para una aplicacion web sencilla 1. Anotar los pasos del proceso de como se haria manualmente. 2. Crear el archivo Dockerfile con las instrucciones 3. Crear la imagen con el comando de compilacion de Docker 4. Subir la imagen a dockerfile para que sea publica Dockerfile Layered architecture Docker build output failure","title":"How to create my own image?"},{"location":"ckad/#002-commands","text":"docker build -t webapp-color .","title":"002 - Commands"},{"location":"ckad/#003-commands-and-arguments-in-docker","text":"docker run ubuntu : Crea y ejecuta un contenedor con la imagen ubuntu . docker ps : Muestra los contenedores activos en ejecuci\u00f3n. docker ps -a : Lista todos los contenedores, incluidos los detenidos. docker run ubuntu [COMMAND] : Ejecuta un contenedor basado en ubuntu con el comando especificado. docker run ubuntu sleep 5 : Inicia un contenedor con ubuntu y ejecuta el comando sleep 5 (espera 5 segundos). docker build -t ubuntu-sleeper . : Construye una imagen llamada ubuntu-sleeper a partir del Dockerfile en el directorio actual. docker run ubuntu-sleeper : Ejecuta un contenedor basado en la imagen ubuntu-sleeper . docker run ubuntu-sleeper sleep 10 docker run ubuntu-sleeper 10","title":"003 - Commands and Arguments in Docker"},{"location":"ckad/#004-commands-and-arguments-in-kubernetes","text":"docker run --name ubuntu-sleeper ubuntu-sleeper docker run --name ubuntu-sleeper ubuntu sleeper 10","title":"004 - Commands and Arguments in Kubernetes"},{"location":"ckad/#005-a-quick-note-on-editing-pods-and-deployments","text":"A quick note on editing Pods and Deployments","title":"005 - A quick note on editing Pods and Deployments"},{"location":"ckad/#edit-a-pod","text":"Remember, you CANNOT edit specifications of an existing POD other than the below. - spec.containers\\[\\*\\].image - spec.initContainers\\[\\*\\].image - spec.activeDeadlineSeconds - spec.tolerations For example you cannot edit the environment variables, service accounts, resource limits (all of which we will discuss later) of a running pod. But if you really want to, you have 2 options: 1. Run the kubectl edit pod <pod name> command. This will open the pod specification in an editor (vi editor). Then edit the required properties. When you try to save it, you will be denied. This is because you are attempting to edit a field on the pod that is not editable. ![](https://img-c.udemycdn.com/redactor/raw/2019-05-30_14-46-21-89ea56fea6b993ee0ccff1625b13341e.PNG) ![](https://img-c.udemycdn.com/redactor/raw/2019-05-30_14-47-14-07b2638d1a72cb2d5b000c00971f6436.PNG) A copy of the file with your changes is saved in a temporary location as shown above. You can then delete the existing pod by running the command: kubectl delete pod webapp Then create a new pod with your changes using the temporary file kubectl create -f /tmp/kubectl-edit-ccvrq.yaml 2. The second option is to extract the pod definition in YAML format to a file using the command kubectl get pod webapp -o yaml > my-new-pod.yaml Then make the changes to the exported file using an editor (vi editor). Save the changes vi my-new-pod.yaml Then delete the existing pod kubectl delete pod webapp Then create a new pod with the edited file kubectl create -f my-new-pod.yaml","title":"Edit a POD"},{"location":"ckad/#edit-deployments","text":"With Deployments you can easily edit any field/property of the POD template. Since the pod template is a child of the deployment specification, with every change the deployment will automatically delete and create a new pod with the new changes. So if you are asked to edit a property of a POD part of a deployment you may do that simply by running the command kubectl edit deployment my-deployment","title":"Edit Deployments"},{"location":"ckad/#006-environment-variables","text":"En Kubernetes, las Environment Variables son configuraciones que puedes pasar a los contenedores para personalizar su comportamiento. Se definen en el manifiesto del pod o Deployment bajo la secci\u00f3n env . Estas variables pueden tener valores fijos o din\u00e1micos, obtenidos de ConfigMaps o Secrets, y son \u00fatiles para almacenar configuraciones como credenciales o URLs sin codificarlas directamente. Ejemplo de configuraci\u00f3n: ```yaml env: - name: APP_ENV value: production - name: DATABASE_URL valueFrom: secretKeyRef: name: db-secret key: url [![image.png](http://10.10.56.89/uploads/images/gallery/2025-01/scaled-1680-/zwUimage.png)](http://10.10.56.89/uploads/images/gallery/2025-01/zwUimage.png) En Kubernetes, los valores de las **Environment Variables** pueden definirse de tres formas principales: - **Valores fijos**: Se especifican directamente en el manifiesto. ```yaml env: - name: APP_ENV value: production Valores din\u00e1micos desde ConfigMaps o Secrets : Se obtienen de estos objetos para gestionar configuraciones sensibles o centralizadas env: - name: DATABASE_URL valueFrom: configMapKeyRef: name: app-config key: database_url","title":"006 - Environment Variables"},{"location":"ckad/#007-configmaps","text":"Un ConfigMap en Kubernetes es un objeto utilizado para almacenar datos de configuraci\u00f3n no sensibles en pares clave-valor. Permite desacoplar la configuraci\u00f3n del c\u00f3digo de la aplicaci\u00f3n, haciendo que sea m\u00e1s f\u00e1cil modificar configuraciones sin necesidad de redeployar. Los ConfigMaps pueden ser referenciados en pods como variables de entorno, archivos montados en vol\u00famenes o argumentos del contenedor. Esto los hace ideales para gestionar configuraciones como URLs, nombres de servidores y par\u00e1metros de aplicaciones.","title":"007 - ConfigMaps"},{"location":"ckad/#imperative","text":"","title":"Imperative"},{"location":"ckad/#declarative","text":"","title":"Declarative"},{"location":"ckad/#core-concepts","text":"","title":"Core Concepts"},{"location":"ckad/#001-recap-kubernetes-architecture","text":"","title":"001 - Recap - Kubernetes Architecture"},{"location":"ckad/#node","text":"Un Node en Kubernetes es una m\u00e1quina (f\u00edsica o virtual) que ejecuta los pods, proporcionando los recursos de CPU, memoria, red y almacenamiento necesarios. Cada Node tiene un agente kubelet que comunica su estado con el cl\u00faster y administra los contenedores","title":"Node:"},{"location":"ckad/#cluster","text":"Un Cluster en Kubernetes es un conjunto de nodos (m\u00e1quinas) que trabajan juntos para ejecutar aplicaciones en contenedores. Est\u00e1 compuesto por un control plane que gestiona el estado del cl\u00faster y los nodes que ejecutan los workloads","title":"Cluster:"},{"location":"ckad/#master","text":"El Master en Kubernetes (o Control Plane) es el componente central que administra el cl\u00faster, coordinando las actividades de los nodos. Incluye el API Server , Scheduler , Controller Manager y etcd para gestionar el estado y la configuraci\u00f3n del cl\u00faster.","title":"Master:"},{"location":"ckad/#componentes","text":"Los componentes principales de Kubernetes son: Control Plane : API Server : Gestiona la comunicaci\u00f3n entre los usuarios y el cl\u00faster. etcd : Almac\u00e9n clave-valor para el estado del cl\u00faster. Scheduler : Asigna pods a nodos seg\u00fan recursos y pol\u00edticas. Controller Manager : Gestiona controladores, como replicaci\u00f3n y endpoints. Node Components : Kubelet : Agente que asegura que los contenedores est\u00e9n en ejecuci\u00f3n. Kube-proxy : Gestiona la red y el acceso a los servicios. Container Runtime : Ejecuta contenedores (e.g., Docker, containerd).","title":"Componentes:"},{"location":"ckad/#master-vs-worker-nodes","text":"","title":"Master vs Worker Nodes"},{"location":"ckad/#master-node-control-plane","text":"Administra el cl\u00faster y toma decisiones como programar pods. Componentes clave: API Server , etcd , Scheduler , y Controller Manager . No ejecuta aplicaciones directamente (excepto en cl\u00fasteres peque\u00f1os, como Minikube).","title":"Master Node (Control Plane):"},{"location":"ckad/#worker-node","text":"Ejecuta los pods con las aplicaciones y cargas de trabajo. Componentes clave: Kubelet , Kube-proxy , y el Container Runtime . Recibe instrucciones del Master Node para ejecutar y gestionar los pods. En resumen, el Master coordina y los Worker Nodes ejecutan.","title":"Worker Node:"},{"location":"ckad/#kubectl","text":"kubectl es la herramienta de l\u00ednea de comandos para interactuar con un cl\u00faster de Kubernetes. Permite gestionar recursos como pods, servicios, y deployments, as\u00ed como monitorear el estado del cl\u00faster y ejecutar comandos en los contenedores.","title":"Kubectl"},{"location":"ckad/#002-docker-vs-containerd","text":"","title":"002 - Docker-vs-ContainerD"},{"location":"ckad/#docker","text":"Descripci\u00f3n : Docker es una plataforma completa que facilita la creaci\u00f3n, env\u00edo y ejecuci\u00f3n de contenedores. Incluye un conjunto de herramientas como el Docker Engine , Docker Compose , y Docker Hub . Uso : Adem\u00e1s de ejecutar contenedores, tambi\u00e9n gestiona la construcci\u00f3n de im\u00e1genes y la orquestaci\u00f3n con Docker Swarm.","title":"Docker:"},{"location":"ckad/#containerd","text":"Descripci\u00f3n : containerd es un runtime de contenedores que proporciona las funcionalidades b\u00e1sicas necesarias para ejecutar contenedores, como la ejecuci\u00f3n de contenedores, la gesti\u00f3n de im\u00e1genes y la administraci\u00f3n del ciclo de vida de los contenedores. Es m\u00e1s ligero y especializado en la ejecuci\u00f3n de contenedores, sin las herramientas adicionales que ofrece Docker. Uso : Usado por Kubernetes y otras plataformas de contenedores para gestionar la ejecuci\u00f3n de contenedores.","title":"containerd:"},{"location":"ckad/#diferencia-clave","text":"Docker es m\u00e1s una plataforma completa que gestiona todo el ciclo de vida de los contenedores, mientras que containerd se centra en la ejecuci\u00f3n y gesti\u00f3n de contenedores, siendo m\u00e1s eficiente para proyectos espec\u00edficos.","title":"Diferencia clave:"},{"location":"ckad/#003-recap-pods","text":"","title":"003 - Recap - Pods"},{"location":"ckad/#pod","text":"Un Pod en Kubernetes es la unidad b\u00e1sica de despliegue que puede contener uno o m\u00e1s contenedores (t\u00edpicamente en el mismo host). Los contenedores dentro de un pod comparten el mismo almacenamiento, red y especificaciones, lo que permite una estrecha comunicaci\u00f3n y gesti\u00f3n eficiente. Los pods son ef\u00edmeros y gestionados por el control plane de Kubernetes.","title":"POD"},{"location":"ckad/#multi-container-pod","text":"Un Multi-Container Pod en Kubernetes es un pod que contiene m\u00e1s de un contenedor. Estos contenedores comparten red, almacenamiento y contexto, permitiendo una comunicaci\u00f3n eficiente. Se usan para patrones como: Sidecar : Un contenedor complementa al principal, como un proxy o logger. Adapter : Transforma datos para otro contenedor en el mismo pod. Ambassador : Maneja la comunicaci\u00f3n con servicios externos. Todos los contenedores trabajan como una unidad cohesiva para cumplir un objetivo com\u00fan.","title":"Multi-Container Pod"},{"location":"ckad/#kubectl_1","text":"","title":"Kubectl"},{"location":"ckad/#004-pods-with-yaml","text":"","title":"004 - Pods with YAML"},{"location":"ckad/#yaml","text":"YAML (Yet Another Markup Language) es un formato de texto legible para humanos usado en Kubernetes para definir recursos del cl\u00faster. Es jer\u00e1rquico y utiliza espacios para estructurar datos en clave-valor.","title":"YAML"},{"location":"ckad/#cuatro-campos-de-nivel-superior","text":"","title":"Cuatro campos de nivel superior"},{"location":"ckad/#comandos","text":"kubectl run redis --image=redis123 --dry-run=client -o yaml","title":"Comandos"},{"location":"ckad/#005-creating-pod-with-yaml","text":"apiVersion: v1 kind: Pod metadata: name: myapp-pod labels: app: myapp costcenter: amer location: MX spec: containers: - name: nginx-container image: nginx","title":"005 - Creating Pod with YAML"},{"location":"ckad/#006-edit-pods","text":"","title":"006 - Edit PODS"},{"location":"ckad/#edit-pods","text":"","title":"Edit Pods"},{"location":"ckad/#a-note-on-editing-existing-pods","text":"In any of the practical quizzes, if you are asked to edit an existing POD , please note the following: - If you are given a pod definition file, edit that file and use it to create a new pod. - **If you are not given a pod definition file**, you may extract the definition to a file using the below command: `kubectl get pod -o yaml > pod-definition.yaml` Then edit the file to make the necessary changes, delete, and re-create the pod. - To modify the properties of the pod, you can utilize the `kubectl edit pod `command. Please note that only the properties listed below are editable. - spec.containers\\[\\*\\].image - spec.initContainers\\[\\*\\].image - spec.activeDeadlineSeconds - spec.tolerations - spec.terminationGracePeriodSeconds","title":"A Note on Editing Existing Pods"},{"location":"ckad/#007-replicasets","text":"Replica Una r\u00e9plica en Kubernetes es una instancia de un pod que forma parte de un ReplicaSet o Deployment. Su prop\u00f3sito es garantizar alta disponibilidad y escalabilidad al duplicar aplicaciones en varios nodos. El n\u00famero de r\u00e9plicas se define en el campo replicas en el manifiesto YAML del recurso. Por ejemplo, con replicas: 3 , Kubernetes mantiene siempre tres pods activos. ccReplicaset Un ReplicaSet en Kubernetes asegura que un n\u00famero espec\u00edfico de r\u00e9plicas de un pod est\u00e9n siempre corriendo en el cl\u00faster. Si un pod falla o es eliminado, el ReplicaSet lo reemplaza autom\u00e1ticamente. Replicaset Controller El ReplicaSet Controller es un controlador en Kubernetes que gestiona los recursos ReplicaSet . Su funci\u00f3n principal es garantizar que el n\u00famero deseado de r\u00e9plicas de un pod est\u00e9 siempre en ejecuci\u00f3n en el cl\u00faster.","title":"007 - Replicasets"},{"location":"ckad/#funciones-clave-del-replicaset-controller","text":"Mantener el n\u00famero de r\u00e9plicas: Si un pod falla o se elimina, crea uno nuevo para cumplir con el n\u00famero especificado en replicas . Autoescalado: Permite aumentar o disminuir manualmente el n\u00famero de r\u00e9plicas seg\u00fan las necesidades. Reconciliaci\u00f3n: Compara constantemente el estado actual del cl\u00faster con el estado deseado y act\u00faa para mantenerlos alineados. Crear Replicacion Controller rc-definition.yml apiVersion: v1 kind: ReplicationController metadata: name: myapp-rc labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 2 ```bash kubectl create -f rc-definition.yml ```bash kubectl get replicationcontroller Crear ReplicaSet replicaset-definition.yml apiVersion: apps/v1 kind: ReplicaSet metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 3 selector: matchLabels: type: front-end ```bash kubectl create -f replicaset-definition.yml ```bash kubectl get replicaset Labels and Selectors Scale kubectl replace -f replicaset-definition.yml kubectl scale --replicas=7 -f replicaset-definition.yml kubectl scale --replicas=8 replicaset myapp-replicaset","title":"Funciones clave del ReplicaSet Controller:"},{"location":"ckad/#008-deployments","text":"","title":"008 - Deployments"},{"location":"ckad/#deployment","text":"Un Deployment en Kubernetes es un recurso que administra la creaci\u00f3n y el escalado de pods, asegurando que siempre cumplan con el estado deseado. Facilita las actualizaciones y escalabilidad de aplicaciones. Permite implementar estrategias como actualizaciones progresivas (rolling updates) y revertir cambios si algo falla. Es ideal para gestionar aplicaciones de forma declarativa y mantener alta disponibilidad.","title":"Deployment"},{"location":"ckad/#rolling-updates","text":"Las rolling updates en Kubernetes son una estrategia para actualizar aplicaciones sin interrupciones. Kubernetes reemplaza gradualmente los pods antiguos por nuevos, asegurando que la aplicaci\u00f3n permanezca disponible durante el proceso. Se controla el n\u00famero de pods que se crean o eliminan simult\u00e1neamente usando los par\u00e1metros maxUnavailable y maxSurge en el Deployment. Esto permite realizar actualizaciones de forma segura y progresiva.","title":"Rolling updates"},{"location":"ckad/#definition","text":"Un Deployment en Kubernetes est\u00e1 compuesto por los siguientes elementos clave: Metadata : Incluye informaci\u00f3n como el nombre del Deployment y etiquetas que ayudan a identificar recursos asociados. Spec (Especificaci\u00f3n) : Define el estado deseado, incluyendo el n\u00famero de r\u00e9plicas, el selector de pods, y la plantilla del pod (contenedores, im\u00e1genes y configuraciones). Selector : Identifica los pods gestionados por el Deployment bas\u00e1ndose en etiquetas. deployment-definition.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 6 selector: matchLabels: type: front-end ``` kubectl create -f deployment-definition.yaml kubectl get deployments kubectl get replicaset kubectl get pods kubectl get all # 009 - Certification Tip: Formatting Output with kubectl The default output format for all **kubectl** commands is the human-readable plain-text format. The -o flag allows us to output the details in several different formats. **kubectl \\[command\\] \\[TYPE\\] \\[NAME\\] -o &lt;output\\_format&gt;** Here are some of the commonly used formats: 1. `-o json`Output a JSON formatted API object. 2. `-o name`Print only the resource name and nothing else. 3. `-o wide`Output in the plain-text format with any additional information. 4. `-o yaml`Output a YAML formatted API object. Here are some useful examples: - **Output with JSON format:** ```json master $ kubectl create namespace test-123 --dry-run -o json { \"kind\": \"Namespace\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"test-123\", \"creationTimestamp\": null }, \"spec\": {}, \"status\": {} } master $ Output with YAML format: master $ kubectl create namespace test-123 --dry-run -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: null name: test-123 spec: {} status: {} Output with wide (additional details): Probably the most common format used to print additional details about the object: master $ kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES busybox 1/1 Running 0 3m39s 10.36.0.2 node01 <none> <none> ningx 1/1 Running 0 7m32s 10.44.0.1 node03 <none> <none> redis 1/1 Running 0 3m59s 10.36.0.1 node01 <none> <none> master $ For more details, refer: https://kubernetes.io/docs/reference/kubectl/overview/ https://kubernetes.io/docs/reference/kubectl/cheatsheet /","title":"Definition"},{"location":"ckad/#010-namespaces","text":"Un namespace en Kubernetes es un mecanismo l\u00f3gico para dividir recursos dentro de un cl\u00faster. Ayuda a organizar y aislar aplicaciones, facilitando la gesti\u00f3n de m\u00faltiples equipos o entornos (como desarrollo, pruebas y producci\u00f3n) en un mismo cl\u00faster. Los namespaces permiten que recursos con el mismo nombre coexistan en el cl\u00faster, siempre que pertenezcan a namespaces diferentes. Kubernetes incluye namespaces predeterminados como default , kube-system y kube-public . El aislamiento en namespaces de Kubernetes permite separar recursos y configuraciones entre diferentes espacios l\u00f3gicos dentro del cl\u00faster. Esto asegura que las aplicaciones o servicios de un namespace no interfieran con los de otro. Cada namespace tiene su propio conjunto de recursos, como pods, servicios y configuraciones, permitiendo un control granular de acceso mediante roles y pol\u00edticas ( Role y RoleBinding ). Este enfoque es \u00fatil para gestionar m\u00faltiples equipos o entornos en un mismo cl\u00faster. n Kubernetes, los namespaces pueden tener l\u00edmites de recursos definidos para controlar el consumo de CPU y memoria dentro de ellos. Esto se logra utilizando un objeto llamado ResourceQuota , que establece restricciones en el uso total de recursos en un namespace espec\u00edfico. Por ejemplo, se puede limitar la cantidad total de memoria o CPU que los pods en un namespace pueden usar, evitando que una aplicaci\u00f3n consuma m\u00e1s de lo asignado y afecte a otras aplicaciones en el cl\u00faster. Esto mejora la gesti\u00f3n de recursos y la estabilidad del sistema. Un ResourceQuota en Kubernetes es un objeto que impone l\u00edmites en el uso total de recursos dentro de un namespace. Controla la cantidad de recursos como CPU, memoria, pods, servicios y almacenamiento que los usuarios o aplicaciones pueden consumir en ese namespace. Se utiliza para evitar que un namespace consuma m\u00e1s recursos de los permitidos, asegurando una distribuci\u00f3n justa en el cl\u00faster. Es especialmente \u00fatil en cl\u00fasteres compartidos por m\u00faltiples equipos o aplicaciones.","title":"010 - Namespaces"},{"location":"ckad/#011-certification-tip-imperative-commands","text":"While you would be working mostly the declarative way - using definition files, imperative commands can help in getting one-time tasks done quickly, as well as generate a definition template easily. This would help save a considerable amount of time during your exams. Before we begin, familiarize yourself with the two options that can come in handy while working with the below commands: --dry-run : By default, as soon as the command is run, the resource will be created. If you simply want to test your command, use the --dry-run=client option. This will not create the resource. Instead, tell you whether the resource can be created and if your command is right. -o yaml : This will output the resource definition in YAML format on the screen. Use the above two in combination along with Linux output redirection to generate a resource definition file quickly, that you can then modify and create resources as required, instead of creating the files from scratch. kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx-pod.yaml","title":"011 - Certification Tip: Imperative Commands"},{"location":"ckad/#pod_1","text":"Create an NGINX Pod kubectl run nginx --image=nginx Generate POD Manifest YAML file (-o yaml). Don't create it(--dry-run) kubectl run nginx --image=nginx --dry-run=client -o yaml","title":"POD"},{"location":"ckad/#deployment_1","text":"Create a deployment kubectl create deployment --image=nginx nginx Generate Deployment YAML file (-o yaml). Don't create it(--dry-run) kubectl create deployment --image=nginx nginx --dry-run -o yaml Generate Deployment with 4 Replicas kubectl create deployment nginx --image=nginx --replicas=4 You can also scale deployment using the kubectl scale command. kubectl scale deployment nginx --replicas=4 Another way to do this is to save the YAML definition to a file and modify kubectl create deployment nginx --image=nginx --dry-run=client -o yaml > nginx-deployment.yaml You can then update the YAML file with the replicas or any other field before creating the deployment.","title":"Deployment"},{"location":"ckad/#service","text":"Create a Service named redis-service of type ClusterIP to expose pod redis on port 6379 kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml (This will automatically use the pod's labels as selectors) Or kubectl create service clusterip redis --tcp=6379:6379 --dry-run=client -o yaml (This will not use the pods' labels as selectors; instead it will assume selectors as app=redis. You cannot pass in selectors as an option. So it does not work well if your pod has a different label set. So generate the file and modify the selectors before creating the service) Create a Service named nginx of type NodePort to expose pod nginx's port 80 on port 30080 on the nodes: kubectl expose pod nginx --port=80 --name nginx-service --type=NodePort --dry-run=client -o yaml (This will automatically use the pod's labels as selectors, but you cannot specify the node port . You have to generate a definition file and then add the node port in manually before creating the service with the pod.) Or kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml (This will not use the pods' labels as selectors) Both the above commands have their own challenges. While one of it cannot accept a selector the other cannot accept a node port. I would recommend going with the kubectl expose command. If you need to specify a node port, generate a definition file using the same command and manually input the nodeport before creating the service. Reference: https://kubernetes.io/docs/reference/kubectl/conventions/","title":"Service"},{"location":"ckad/#practice-test","text":"","title":"Practice Test"},{"location":"ckad/#001-pods","text":"Create a new pod with the nginx image. kubectl run nginx --image=nginx Delete the webapp Pod. kubectl delete pod webapp Create a new pod with the name redis and the image redis123 . Metodo 1: kubectl run redis --image=redis123 -o yaml pod-definition.yaml apiVersion: v1 kind: Pod metadata: creationTimestamp: \"2025-01-27T19:03:35Z\" labels: run: redis name: redis namespace: default resourceVersion: \"1059\" uid: 74c5fb2d-9479-4d03-ba3b-509663a2245b spec: containers: - image: redis123 imagePullPolicy: Always name: redis resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /var/run/secrets/kubernetes.io/serviceaccount name: kube-api-access-5k4xq readOnly: true dnsPolicy: ClusterFirst enableServiceLinks: true preemptionPolicy: PreemptLowerPriority priority: 0 restartPolicy: Always schedulerName: default-scheduler securityContext: {} serviceAccount: default serviceAccountName: default terminationGracePeriodSeconds: 30 tolerations: - effect: NoExecute key: node.kubernetes.io/not-ready operator: Exists tolerationSeconds: 300 - effect: NoExecute key: node.kubernetes.io/unreachable operator: Exists tolerationSeconds: 300 volumes: - name: kube-api-access-5k4xq projected: defaultMode: 420 sources: - serviceAccountToken: expirationSeconds: 3607 path: token - configMap: items: - key: ca.crt path: ca.crt name: kube-root-ca.crt - downwardAPI: items: - fieldRef: apiVersion: v1 fieldPath: metadata.namespace path: namespace status: phase: Pending qosClass: BestEffort Metodo 2: pod-definition-v1.yaml apiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis123","title":"001 - Pods"},{"location":"ckad/#002-replicasets","text":"Create a ReplicaSet using the replicaset-definition-1.yaml file located at /root/ . There is an issue with the file, so try to fix it. Issue apiVersion: v1 kind: ReplicaSet metadata: name: replicaset-1 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: frontend spec: containers: - name: nginx image: nginx ```bash kubectl api-resources | grep replicaset <details id=\"bkmrk-fixed-apiversion%3A-ap\"><summary>Fixed</summary> ```yaml apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-1 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: frontend spec: containers: - name: nginx image: nginx Fix the issue in the replicaset-definition-2.yaml file and create a ReplicaSet using it. This file is located at /root/ . Issue apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-2 spec: replicas: 2 selector: matchLabels: tier: frontend template: metadata: labels: tier: nginx spec: containers: - name: nginx image: nginx Fixed apiVersion: apps/v1 kind: ReplicaSet metadata: name: replicaset-2 spec: replicas: 2 selector: matchLabels: tier: nginx template: metadata: labels: tier: nginx spec: containers: - name: nginx image: nginx Fix the original replica set new-replica-set to use the correct busybox image. Either delete and recreate the ReplicaSet or Update the existing ReplicaSet and then delete all PODs, so new ones with the correct image will be created. kubectl edit replicaset new-replica-set Issue apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 2 name: new-replica-set namespace: default resourceVersion: \"1593\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 4 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox777 imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: fullyLabeledReplicas: 4 observedGeneration: 2 replicas: 4 Fixed apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 2 name: new-replica-set namespace: default resourceVersion: \"1593\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 4 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: fullyLabeledReplicas: 4 observedGeneration: 2 replicas: 4 ```bash kubectl delete pod new-replica-set-mr7mk new-replica-set-rvlcc new-replica-set-vn9fs Scale the ReplicaSet to 5 PODs. Use `kubectl scale` command or edit the replicaset using `kubectl edit replicaset`. Metodo Imperativo ```bash kubectl scale --replicas=5 rs/new-replica-set Metodo Declarativo kubectl edit rs new-replica-set apiVersion: apps/v1 kind: ReplicaSet metadata: creationTimestamp: \"2025-01-27T19:19:58Z\" generation: 7 name: new-replica-set namespace: default resourceVersion: \"1955\" uid: aed6557a-5462-4d6d-8e41-39216539f2f4 spec: replicas: 5 selector: matchLabels: name: busybox-pod template: metadata: creationTimestamp: null labels: name: busybox-pod spec: containers: - command: - sh - -c - echo Hello Kubernetes! && sleep 3600 image: busybox imagePullPolicy: Always name: busybox-container resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File dnsPolicy: ClusterFirst restartPolicy: Always schedulerName: default-scheduler securityContext: {} terminationGracePeriodSeconds: 30 status: availableReplicas: 5 fullyLabeledReplicas: 5 observedGeneration: 7 readyReplicas: 5 replicas: 5 Now scale the ReplicaSet down to 2 PODs. Use the kubectl scale command or edit the replicaset using kubectl edit replicaset . kubectl scale --replicas=2 rs/new-replica-set","title":"002 - Replicasets"},{"location":"ckad/#003-deployments","text":"Create a new Deployment using the deployment-definition-1.yaml file located at /root/ . There is an issue with the file, so try to fix it. --- apiVersion: apps/v1 kind: deployment metadata: name: deployment-1 spec: replicas: 2 selector: matchLabels: name: busybox-pod template: metadata: labels: name: busybox-pod spec: containers: - name: busybox-container image: busybox888 command: - sh - \"-c\" - echo Hello Kubernetes! && sleep 3600 deployment-definition-1.yaml \\[Fixed\\] --- apiVersion: apps/v1 kind: Deployment metadata: name: deployment-1 spec: replicas: 2 selector: matchLabels: name: busybox-pod template: metadata: labels: name: busybox-pod spec: containers: - name: busybox-container image: busybox command: - sh - \"-c\" - echo Hello Kubernetes! && sleep 3600 Create a new Deployment with the below attributes using your own deployment definition file. Name: httpd-frontend ; Replicas: 3 ; Image: httpd:2.4-alpine","title":"003 - Deployments"},{"location":"ckad/#004-namespaces","text":"How many pods exist in the research namespace? Solution kubectl get pods -n research Create a POD in the finance namespace. Use the spec given below. - Name: redis - Image name: redis Solution kubectl run redis --image=redis -n finance Which namespace has the `blue` pod in it? Hint kubectl get pods --all-namespaces","title":"004 - Namespaces"},{"location":"ckad/#005-imperative-commands","text":"","title":"005 - Imperative Commands"},{"location":"ckad/#skels","text":"","title":"Skels"},{"location":"ckad/#001-pods_1","text":"apiVersion: v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: Pod # Obligatorio: Tipo de recurso (en este caso, Pod). metadata: name: <nombre-del-pod> # Obligatorio: Nombre \u00fanico del Pod. labels: # Opcional: Etiquetas para identificar el Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\" restartPolicy: Always # Opcional: Pol\u00edtica de reinicio (Always, OnFailure, Never).","title":"001 - Pods"},{"location":"ckad/#002-replicasets_1","text":"apiVersion: apps/v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: ReplicaSet # Obligatorio: Tipo de recurso (en este caso, ReplicaSet). metadata: name: <nombre-del-replicaset> # Obligatorio: Nombre \u00fanico del ReplicaSet. labels: # Opcional: Etiquetas para identificar el ReplicaSet. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del ReplicaSet. replicas: <n\u00famero-de-r\u00e9plicas> # Obligatorio: N\u00famero de Pods que deseas ejecutar. selector: # Obligatorio: Selector para identificar los Pods gestionados. matchLabels: app: <etiqueta-app> # Debe coincidir con las etiquetas del Pod. template: # Obligatorio: Plantilla para crear los Pods. metadata: labels: # Obligatorio: Etiquetas del Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\"","title":"002 - Replicasets"},{"location":"ckad/#003-deployments_1","text":"apiVersion: apps/v1 # Obligatorio: Versi\u00f3n de la API de Kubernetes. kind: Deployment # Obligatorio: Tipo de recurso (en este caso, Deployment). metadata: name: <nombre-del-deployment> # Obligatorio: Nombre \u00fanico del Deployment. labels: # Opcional: Etiquetas para identificar el Deployment. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Deployment. replicas: <n\u00famero-de-r\u00e9plicas> # Opcional: N\u00famero de Pods que deseas ejecutar (por defecto es 1). selector: # Obligatorio: Selector para identificar los Pods gestionados. matchLabels: app: <etiqueta-app> # Debe coincidir con las etiquetas del Pod. template: # Obligatorio: Plantilla para crear los Pods. metadata: labels: # Obligatorio: Etiquetas del Pod. app: <etiqueta-app> spec: # Obligatorio: Especificaci\u00f3n del Pod. containers: # Obligatorio: Lista de contenedores en el Pod. - name: <nombre-del-contenedor> # Obligatorio: Nombre del contenedor. image: <imagen-del-contenedor> # Obligatorio: Imagen del contenedor. ports: # Opcional: Puertos que expone el contenedor. - containerPort: <puerto-del-contenedor> env: # Opcional: Variables de entorno. - name: <nombre-de-la-variable> value: \"<valor-de-la-variable>\" resources: # Opcional: L\u00edmites y solicitudes de recursos. requests: memory: \"<memoria-m\u00ednima>\" cpu: \"<cpu-m\u00ednima>\" limits: memory: \"<memoria-m\u00e1xima>\" cpu: \"<cpu-m\u00e1xima>\"","title":"003 - Deployments"}]}